{"name":"atomics.net","tagline":"Enables .NET projects to use atomic primitives.","body":"# atomics.net\r\n\r\n[![Build status](https://ci.appveyor.com/api/projects/status/wnh7fat3oqas0wer?svg=true)](https://ci.appveyor.com/project/szKarlen/atomics-net) [![NuGet](https://img.shields.io/nuget/v/System.Threading.Atomics.svg?style=flat)](http://www.nuget.org/profiles/Karlen)\r\n\r\nThis package enables .NET projects to use atomic primitives.\r\n\r\nDesign and implementation\r\n-------\r\n\r\nProject aims to be very close to C++ 11 standard atomics by design and usage. For example, The [memory order](http://en.cppreference.com/w/cpp/atomic/memory_order) flag could be provided to primitives.\r\n\r\nAlthough the library is a PCL itself, the minimum required version of .NET - 4.5. But you can compile for .NET 4.0 and earlier. The Itanium-related stuff (volatile reads with proper memory barriers usages, etc.) will be present by using ITANIUM_CPU directive (see [docs](Documentation/memorymodel101.md)).\r\n\r\nFor ECMA MM implementations of CLI on ARM architecture the conditional compilation is supported by using ARM_CPU directive.\r\n\r\nThe default memory semantics for the library's primitives (like `Atomic<T>`, etc.) is `MemoryOrder.SeqCst`, whereas `AtomicReference<T>` uses `MemoryOrder.AcqRel`, which fits very well with CAS approach and CLR 2.0 memory model.\r\n\r\nThe option for sequential consistency (i.e. `SeqCst`) is implemented by using intrinsic functions (with compilation to proper CPU instruction) or a combination of Acquire/Release with sequential order emulation through exclusion locks, when atomic read/writes to particular POD are not supported by HW.\r\n\r\nSpecifying Acquire only or Release only flag falls back to full Acquire/Release semantics for get/set operations or combinations of.\r\n\r\nAtomic primitives\r\n-------\r\n\r\n* `Atomic<T>`\r\n* `AtomicReference<T>`\r\n* `AtomicInteger`\r\n* `AtomicLong`\r\n* `AtomicBoolean`\r\n\r\nSupported types and operations\r\n-------\r\nRead/writes operations on references are provided by `AtomicReference<T>`.\r\nThe `Atomic<T>` class should be used for structs (i.e. value types), including (`char`, `byte`, etc.).\r\n\r\n`AtomicInteger` and `AtomicLong` classes has support for `+, -, *, /, ++, --, +=, -=, *=, /=` operators with atomicity guarantees.\r\n\r\nAll primitives implement the implicit conversion operator overloads with atomic access.\r\n\r\nIntegers ranging from 8 to 64 bit are supported as well as unsigned ones.\r\n\r\nFalse Sharing\r\n-------\r\n\r\n`AtomicInteger` and `AtomicLong` classes has support for memory alignment alongside modern CPU's cache lines. Use flag `align` in constructor of either `Atomic<T>`, `AtomicInteger`, `AtomicLong` or `AtomicBoolean`. Only specializations of `Atomic<T>` with Int32, Int64 and Boolean uses alignment.\r\n\r\nSample usage\r\n-------\r\n\r\nHere is the basic setup and usage of atomic primitives.\r\n\r\n``` csharp\r\nusing System;\r\n\r\nclass Counter\r\n{\r\n    private AtomicInteger _value;\r\n    private readonly bool _isReadOnly;\r\n    \r\n    public Counter(int initialValue = 0, bool isReadOnly = false)\r\n    {\r\n        /*\r\n         * _value = new AtomicInteger(align: true)\r\n         * for false sharing prevention, otherwise as shown below\r\n         */\r\n        _value = initialValue;\r\n        _isReadOnly = isReadOnly;\r\n    }\r\n    \r\n    public void Increment(int value)\r\n    {\r\n        if (!_isReadOnly)\r\n            _value++;\r\n    }\r\n    \r\n    public void PrintCounter()\r\n    {\r\n        Console.WriteLine(_value); // Console.WriteLine(int) overload will be used\r\n    }\r\n}\r\n```\r\n\r\nNotes for usage\r\n-------\r\n\r\n`Atomic<T>` with `Int32`, `Int64` and `Boolean` specialization falls back to using `AtomicInteger`, `AtomicLong` and `AtomicBoolean` as internal storage respectively.\r\n\r\nThe memory order flag as well as alignment transfers to internal storage.\r\n\r\nLock-free stack 101\r\n-------\r\n\r\nIt is very straightforward to implement lock-free stack:\r\n``` csharp\r\npublic class AtomicStack<T>\r\n{\r\n    private AtomicReference<StackNode<T>> _headNode = new AtomicReference<StackNode<T>>();\r\n\r\n    public void Push(T item)\r\n    {\r\n        _headNode.Set((stackNode, data) =>\r\n        {\r\n            StackNode<T> node = new StackNode<T>(data);\r\n            node._next = stackNode;\r\n\r\n            return node;\r\n        }, item);\r\n    }\r\n\r\n    public T Pop()\r\n    {\r\n        if (IsEmpty)\r\n            throw new InvalidOperationException();\r\n\r\n        return _headNode.Set(stackNode => stackNode._next)._value;\r\n    }\r\n\r\n    public bool IsEmpty\r\n    {\r\n        get { return _headNode.Load(MemoryOrder.Acquire) == null; }\r\n    }\r\n\r\n    class StackNode<T>\r\n    {\r\n        internal T _value;\r\n        internal StackNode<T> _next;\r\n        internal StackNode(T val) { _value = val; }\r\n    }\r\n}\r\n```\r\n\r\nand usage:\r\n``` csharp\r\nAtomicStack<int> stack = new AtomicStack<int>();\r\n\r\nParallel.For(0, 100000, stack.Push);\r\n\r\nvar thread = new Thread(() => Parallel.For(0, 50000, index => stack.Pop()));\r\nthread.IsBackground = true;\r\nthread.Start();\r\n\r\nint i = 0;\r\nwhile (!stack.IsEmpty)\r\n{\r\n    stack.Pop();\r\n    i++;\r\n}\r\n\r\nConsole.WriteLine(\"Pushed: {0};\", i); // should print 50000\r\n```\r\n\r\nFor more details about `AtomicStack<T>` example above, please refer [docs](Documentation/lockfreestack101.md).\r\n\r\nCAS notes\r\n-------\r\nUsually **compare-and-swap (CAS)** is used in lock-free algorithms to maintain thread-safety, while avoiding locks. Especially often the `compare_exchange_weak` variation is used.\r\nProvided by the .NET Framework [`Interlocked.CompareExchange`](https://msdn.microsoft.com/ru-ru/library/system.threading.interlocked.compareexchange(v=vs.110).aspx) method is the C++ [`compare_and_exchange_strong`](http://en.cppreference.com/w/cpp/atomic/atomic/compare_exchange) analog. The `compare_exchange_weak` is not supported.\r\n\r\nCurrent implementation of atomics.net uses CAS approach for lock-free atomic operations (the `Atomic<T>.Value` property uses CAS for setter.\r\n\r\nChangelog\r\n-------\r\n* RC3:\r\n  - New `AtomicReference<T>.Set<TData>(Func<T, TData, T>setter, TData data)` method overload\r\n  - New byref `Store(ref T value, MemoryOrder order)` method for `Atomic<T>`, `AtomicInteger`, `AtomicLong` and `AtomicBoolean`\r\n  - Optimization of Acquire/Release and Seq_Cst read/writes performance on x86\r\n  - ITANIUM_CPU conditional compilation support\r\n* RC2:\r\n  - `align` flag support in `Atomic<T>`, `AtomicInteger`, `AtomicLong` and `AtomicBoolean` for false sharing prevention alongside of CPU's cache lines\r\n  - Bug fixes in CAS loops\r\n  - ARM_CPU conditional compilation support\r\n* RC1:\r\n  - `AtomicReference<T>.Set()` method fix for CAS\r\n  - C++ 11 atomic Load/Store methods as well as IsLockFree property support in primitives\r\n  - Docs and samples update\r\n* Beta2:\r\n  - Lock-free stack samples\r\n  - NuGet package support\r\n  - Fixes\r\n* Beta1:\r\n  - Thread interruption support in AtomicInteger, AtomicLong\r\n  - Docs update\r\n* Alpha:\r\n  - Initial milestone of project\r\n  \r\n\r\nContributing\r\n-------\r\n\r\nFeel free to fork and create pull-requests if you have any kind of enhancements and/or bug fixes.\r\n\r\nNuGet\r\n-------\r\n\r\n[Package's page](https://www.nuget.org/packages/System.Threading.Atomics)\r\n\r\nCommand: `PM> Install-Package System.Threading.Atomics -Pre`\r\n\r\nLicense\r\n-------\r\n\r\natomics.net is licensed under the [BSD license](LICENSE).\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}
<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>atomics.net by szKarlen</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">atomics.net</h1>
      <h2 class="project-tagline">This package enables .NET projects to use atomic primitives.</h2>
      <a href="https://github.com/szKarlen/atomics.net" class="btn">View on GitHub</a>
      <a href="https://github.com/szKarlen/atomics.net/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/szKarlen/atomics.net/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="atomicsnet" class="anchor" href="#atomicsnet" aria-hidden="true"><span class="octicon octicon-link"></span></a>atomics.net</h1>

<p><a href="https://ci.appveyor.com/project/szKarlen/atomics-net"><img src="https://ci.appveyor.com/api/projects/status/wnh7fat3oqas0wer?svg=true" alt="Build status"></a> <a href="http://www.nuget.org/profiles/Karlen"><img src="https://img.shields.io/nuget/v/System.Threading.Atomics.svg?style=flat" alt="NuGet"></a></p>

<p>This package enables .NET projects to use atomic primitives.</p>

<h2>
<a id="design-and-implementation" class="anchor" href="#design-and-implementation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Design and implementation</h2>

<p>Project aims to be very close to C++ 11 standard atomics by design and usage. For example, The <a href="http://en.cppreference.com/w/cpp/atomic/memory_order">memory order</a> flag could be provided to primitives.</p>

<p>Although the library is a PCL itself, the minimum required version of .NET - 4.5. But you can compile for .NET 4.0 and earlier. The Itanium-related stuff (volatile reads with proper memory barriers usages, etc.) will be present by using ITANIUM_CPU directive (see <a href="Documentation/memorymodel101.md">docs</a>).</p>

<p>For ECMA MM implementations of CLI on ARM architecture the conditional compilation is supported by using ARM_CPU directive.</p>

<p>The default memory semantics for the library's primitives (like <code>Atomic&lt;T&gt;</code>, etc.) is <code>MemoryOrder.SeqCst</code>, whereas <code>AtomicReference&lt;T&gt;</code> uses <code>MemoryOrder.AcqRel</code>, which fits very well with CAS approach and CLR 2.0 memory model.</p>

<p>The option for sequential consistency (i.e. <code>SeqCst</code>) is implemented by using intrinsic functions (with compilation to proper CPU instruction) or a combination of Acquire/Release with sequential order emulation through exclusion locks, when atomic read/writes to particular POD are not supported by HW.</p>

<p>Specifying Acquire only or Release only flag falls back to full Acquire/Release semantics for get/set operations or combinations of.</p>

<h2>
<a id="atomic-primitives" class="anchor" href="#atomic-primitives" aria-hidden="true"><span class="octicon octicon-link"></span></a>Atomic primitives</h2>

<ul>
<li><code>Atomic&lt;T&gt;</code></li>
<li><code>AtomicReference&lt;T&gt;</code></li>
<li><code>AtomicInteger</code></li>
<li><code>AtomicLong</code></li>
<li><code>AtomicBoolean</code></li>
</ul>

<h2>
<a id="supported-types-and-operations" class="anchor" href="#supported-types-and-operations" aria-hidden="true"><span class="octicon octicon-link"></span></a>Supported types and operations</h2>

<p>Read/writes operations on references are provided by <code>AtomicReference&lt;T&gt;</code>.
The <code>Atomic&lt;T&gt;</code> class should be used for structs (i.e. value types), including (<code>char</code>, <code>byte</code>, etc.).</p>

<p><code>AtomicInteger</code> and <code>AtomicLong</code> classes has support for <code>+, -, *, /, ++, --, +=, -=, *=, /=</code> operators with atomicity guarantees.</p>

<p>All primitives implement the implicit conversion operator overloads with atomic access.</p>

<p>Integers ranging from 8 to 64 bit are supported as well as unsigned ones.</p>

<h2>
<a id="false-sharing" class="anchor" href="#false-sharing" aria-hidden="true"><span class="octicon octicon-link"></span></a>False Sharing</h2>

<p><code>AtomicInteger</code> and <code>AtomicLong</code> classes has support for memory alignment alongside modern CPU's cache lines. Use flag <code>align</code> in constructor of either <code>Atomic&lt;T&gt;</code>, <code>AtomicInteger</code>, <code>AtomicLong</code> or <code>AtomicBoolean</code>. Only specializations of <code>Atomic&lt;T&gt;</code> with Int32, Int64 and Boolean uses alignment.</p>

<h2>
<a id="sample-usage" class="anchor" href="#sample-usage" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sample usage</h2>

<p>Here is the basic setup and usage of atomic primitives.</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">using</span> System<span class="pl-k">;</span>

<span class="pl-k">class</span> <span class="pl-en">Counter</span>
{
    <span class="pl-k">private</span> AtomicInteger _value;
    <span class="pl-k">private</span> <span class="pl-k">readonly</span> <span class="pl-k">bool</span> _isReadOnly;

    <span class="pl-k">public</span> <span class="pl-en">Counter</span>(<span class="pl-k">int</span> <span class="pl-smi">initialValue</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>, <span class="pl-k">bool</span> <span class="pl-smi">isReadOnly</span> <span class="pl-k">=</span> <span class="pl-c1">false</span>)
    {
        <span class="pl-c">/*</span>
<span class="pl-c">         * _value = new AtomicInteger(align: true)</span>
<span class="pl-c">         * for false sharing prevention, otherwise as shown below</span>
<span class="pl-c">         */</span>
        _value = initialValue;
        _isReadOnly = isReadOnly;
    }

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Increment</span>(<span class="pl-k">int</span> <span class="pl-smi">value</span>)
    {
        <span class="pl-k">if</span> (!_isReadOnly)
            _value++;
    }

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">PrintCounter</span>()
    {
        Console.WriteLine(_value); <span class="pl-c">// Console.WriteLine(int) overload will be used</span>
    }
}</pre></div>

<h2>
<a id="notes-for-usage" class="anchor" href="#notes-for-usage" aria-hidden="true"><span class="octicon octicon-link"></span></a>Notes for usage</h2>

<p><code>Atomic&lt;T&gt;</code> with <code>Int32</code>, <code>Int64</code> and <code>Boolean</code> specialization falls back to using <code>AtomicInteger</code>, <code>AtomicLong</code> and <code>AtomicBoolean</code> as internal storage respectively.</p>

<p>The memory order flag as well as alignment transfers to internal storage.</p>

<h2>
<a id="lock-free-stack-101" class="anchor" href="#lock-free-stack-101" aria-hidden="true"><span class="octicon octicon-link"></span></a>Lock-free stack 101</h2>

<p>It is very straightforward to implement lock-free stack:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">AtomicStack</span>&lt;T&gt;
{
    <span class="pl-k">private</span> AtomicReference&lt;StackNode&lt;T&gt;&gt; _headNode = <span class="pl-k">new</span> AtomicReference&lt;StackNode&lt;T&gt;&gt;();

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Push</span>(<span class="pl-k">T</span> <span class="pl-smi">item</span>)
    {
        _headNode.Set((stackNode, data) =&gt;
        {
            StackNode&lt;T&gt; node = <span class="pl-k">new</span> StackNode&lt;T&gt;(data);
            node._next = stackNode;

            <span class="pl-k">return</span> node;
        }, item);
    }

    <span class="pl-k">public</span> T <span class="pl-en">Pop</span>()
    {
        <span class="pl-k">if</span> (IsEmpty)
            <span class="pl-k">throw</span> <span class="pl-k">new</span> InvalidOperationException();

        <span class="pl-k">return</span> _headNode.Set(stackNode =&gt; stackNode._next)._value;
    }

    <span class="pl-k">public</span> <span class="pl-k">bool</span> IsEmpty
    {
        <span class="pl-k">get</span> { <span class="pl-k">return</span> _headNode.Load(MemoryOrder.Acquire) == <span class="pl-c1">null</span>; }
    }

    <span class="pl-k">class</span> <span class="pl-en">StackNode</span>&lt;T&gt;
    {
        <span class="pl-k">internal</span> T _value;
        <span class="pl-k">internal</span> StackNode&lt;T&gt; _next;
        <span class="pl-k">internal</span> <span class="pl-en">StackNode</span>(<span class="pl-k">T</span> <span class="pl-smi">val</span>) { _value = val; }
    }
}</pre></div>

<p>and usage:</p>

<div class="highlight highlight-source-cs"><pre>AtomicStack&lt;<span class="pl-k">int</span>&gt; stack = <span class="pl-k">new</span> AtomicStack&lt;<span class="pl-k">int</span>&gt;();

Parallel.For(<span class="pl-c1">0</span>, <span class="pl-c1">100000</span>, stack.Push);

<span class="pl-k">var</span> thread = <span class="pl-k">new</span> Thread(() =&gt; Parallel.For(<span class="pl-c1">0</span>, <span class="pl-c1">50000</span>, index =&gt; stack.Pop()));
thread.IsBackground = <span class="pl-c1">true</span>;
thread.Start();

<span class="pl-k">int</span> i = <span class="pl-c1">0</span>;
<span class="pl-k">while</span> (!stack.IsEmpty)
{
    stack.Pop();
    i++;
}

Console.WriteLine(<span class="pl-s"><span class="pl-pds">"</span>Pushed: {0};<span class="pl-pds">"</span></span>, i); <span class="pl-c">// should print 50000</span></pre></div>

<p>For more details about <code>AtomicStack&lt;T&gt;</code> example above, please refer <a href="Documentation/lockfreestack101.md">docs</a>.</p>

<h2>
<a id="cas-notes" class="anchor" href="#cas-notes" aria-hidden="true"><span class="octicon octicon-link"></span></a>CAS notes</h2>

<p>Usually <strong>compare-and-swap (CAS)</strong> is used in lock-free algorithms to maintain thread-safety, while avoiding locks. Especially often the <code>compare_exchange_weak</code> variation is used.
Provided by the .NET Framework <a href="https://msdn.microsoft.com/ru-ru/library/system.threading.interlocked.compareexchange(v=vs.110).aspx"><code>Interlocked.CompareExchange</code></a> method is the C++ <a href="http://en.cppreference.com/w/cpp/atomic/atomic/compare_exchange"><code>compare_and_exchange_strong</code></a> analog. The <code>compare_exchange_weak</code> is not supported.</p>

<p>Current implementation of atomics.net uses CAS approach for lock-free atomic operations (the <code>Atomic&lt;T&gt;.Value</code> property uses CAS for setter.</p>

<h2>
<a id="changelog" class="anchor" href="#changelog" aria-hidden="true"><span class="octicon octicon-link"></span></a>Changelog</h2>

<ul>
<li>RC3:

<ul>
<li>New <code>AtomicReference&lt;T&gt;.Set&lt;TData&gt;(Func&lt;T, TData, T&gt;setter, TData data)</code> method overload</li>
<li>New byref <code>Store(ref T value, MemoryOrder order)</code> method for <code>Atomic&lt;T&gt;</code>, <code>AtomicInteger</code>, <code>AtomicLong</code> and <code>AtomicBoolean</code>
</li>
<li>Optimization of Acquire/Release and Seq_Cst read/writes performance on x86</li>
<li>ITANIUM_CPU conditional compilation support</li>
</ul>
</li>
<li>RC2:

<ul>
<li>
<code>align</code> flag support in <code>Atomic&lt;T&gt;</code>, <code>AtomicInteger</code>, <code>AtomicLong</code> and <code>AtomicBoolean</code> for false sharing prevention alongside of CPU's cache lines</li>
<li>Bug fixes in CAS loops</li>
<li>ARM_CPU conditional compilation support</li>
</ul>
</li>
<li>RC1:

<ul>
<li>
<code>AtomicReference&lt;T&gt;.Set()</code> method fix for CAS</li>
<li>C++ 11 atomic Load/Store methods as well as IsLockFree property support in primitives</li>
<li>Docs and samples update</li>
</ul>
</li>
<li>Beta2:

<ul>
<li>Lock-free stack samples</li>
<li>NuGet package support</li>
<li>Fixes</li>
</ul>
</li>
<li>Beta1:

<ul>
<li>Thread interruption support in AtomicInteger, AtomicLong</li>
<li>Docs update</li>
</ul>
</li>
<li>Alpha:

<ul>
<li>Initial milestone of project</li>
</ul>
</li>
</ul>

<h2>
<a id="contributing" class="anchor" href="#contributing" aria-hidden="true"><span class="octicon octicon-link"></span></a>Contributing</h2>

<p>Feel free to fork and create pull-requests if you have any kind of enhancements and/or bug fixes.</p>

<h2>
<a id="nuget" class="anchor" href="#nuget" aria-hidden="true"><span class="octicon octicon-link"></span></a>NuGet</h2>

<p><a href="https://www.nuget.org/packages/System.Threading.Atomics">Package's page</a></p>

<p>Command: <code>PM&gt; Install-Package System.Threading.Atomics -Pre</code></p>

<h2>
<a id="license" class="anchor" href="#license" aria-hidden="true"><span class="octicon octicon-link"></span></a>License</h2>

<p>atomics.net is licensed under the <a href="LICENSE">BSD license</a>.</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/szKarlen/atomics.net">atomics.net</a> is maintained by <a href="https://github.com/szKarlen">szKarlen</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
